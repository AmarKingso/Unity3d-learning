## 改进飞碟（Hit UFO）游戏

- 游戏内容要求:  
  1. 按 adapter模式 设计图修改飞碟游戏  
  2. 使它同时支持物理运动与运动学（变换）运动

### UML图

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191017152029277.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Rpb3NtYWlfa2luZ3Nv,size_16,color_FFFFFF,t_70)

### 实现思路
使用满足物理运动学的原理来实现飞碟的移动即可，再假设不存在任何阻力的情况下，飞碟在飞行时只会受到重力，物体在某一加速度方向上的位移公式为vt+at^2/2，根据此公式实现位移即可  
游戏规则：每轮会扔出十个飞碟，回合数不限，飞碟飞出的速度会随着回合数的提高而提高；当飞碟飞出视野则扣除1点血量，血量为0时游戏结束，若回合结束后血量>0则自动进入下一回合；  
计分规则：飞碟颜色对应分值+飞碟速度分值*飞碟大小分值

### 具体代码
#### UFOData.cs
保存在飞碟上的组件，储存着飞碟相关数值
```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class UFOData : MonoBehaviour{
	public int score;           //飞碟分数
	public int angle;			//飞碟飞出角度
	public float speed;			//初始速度
	public Color color;			//飞碟颜色
	public Vector3 pos;         //飞碟位置
	public Vector3 scale;       //飞碟大小
}
```

#### UFOFactory.cs
飞碟的回收工厂，用于生产和回收飞碟，飞碟的各项随机属性也在工厂中实现
```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class UFOFactory : MonoBehaviour {
	public GameObject ufo;      //飞碟实例
	private List<UFOData> used = new List<UFOData>();     //使用中的飞碟
	private Queue<UFOData> free = new Queue<UFOData>();		//空闲的飞碟

	private void Awake() {
		ufo = GameObject.Instantiate<GameObject>(Resources.Load<GameObject>("Prefabs/ufo"), Vector3.zero, Quaternion.identity);
		ufo.SetActive(false);
	}

	//得到一个飞碟，参数round用于计算当前关卡飞碟速度
	public GameObject getUFO(int round) {
		GameObject need = null;                     //用于返回的游戏对象
		Color color;                                //飞碟的颜色
		int color_choice = Random.Range(0, 3);      //决定飞碟的颜色
		int side = Random.Range(0, 2);              //飞碟从屏幕左右侧飞出
		int angle = Random.Range(0, 21);            //飞碟飞出角度
		int score;                                  //不同颜色对应的分值
		int scale = Random.Range(2, 5);             //飞碟大小
		float y = Random.Range(4f, 6f);

		if (free.Count > 0)                 //有空闲飞碟直接使用
			need = free.Dequeue().gameObject;
		else {                              //没有就生成新的游戏对象
			need = GameObject.Instantiate<GameObject>(ufo, Vector3.zero, Quaternion.identity);
			need.AddComponent<UFOData>();
		}

		if (color_choice == 0) {
			color = Color.red;
			score = 1;
		}
		else if (color_choice == 1) {
			color = Color.blue;
			score = 2;
		}
		else {
			color = Color.green;
			score = 3;
		}

		need.GetComponent<UFOData>().speed = 2 * round + 2f;
		need.GetComponent<UFOData>().color = color;
		need.GetComponent<UFOData>().scale = new Vector3(scale / 4f, 0.05f, scale / 4f);
		need.GetComponent<UFOData>().score = score + (round + 1) * (5 - scale);
		if (side == 0) {
			need.GetComponent<UFOData>().angle = angle;
			need.GetComponent<UFOData>().pos = new Vector3(-12, y, 0);
		}
		else {
			need.GetComponent<UFOData>().angle = 180 - angle;
			need.GetComponent<UFOData>().pos = new Vector3(12, y, 0);
		}

		used.Add(need.GetComponent<UFOData>());

		return need;
	}

	//将使用中的飞碟回收
	public void addToFree(GameObject obj) {
		foreach(var tmp in used) {
			if (tmp.GetInstanceID() == obj.GetComponent<UFOData>().GetInstanceID()) {
				obj.gameObject.SetActive(false);
				used.Remove(tmp);
				free.Enqueue(tmp);
				break;
			}
		}
	}
}
```

#### CCActionManager.cs
增加了一个回调，用于通知工厂进行回收
```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class CCActionManager : SSActionManager, ISSActionCallBack{
	CCFlyAction fly;
	FirstController sc;

	protected void Start() {
		sc = (FirstController)SSDirector.getInstance().currentSceneController;
		sc.am = this;
	}

	public void SSActionEvent(SSAction src, int events = 1, int int_param = 0, string str_param = null, Object obj_param = null) {
		if(src is CCFlyAction) {
			Singleton<UFOFactory>.Instance.addToFree(src.gameobject);
		}
	}

	public void UFOFly(GameObject ufo, float gravity) {
		fly = CCFlyAction.getSSAction(ufo.GetComponent<UFOData>().speed, gravity, ufo.GetComponent<UFOData>().angle);
		//Debug.Log(ufo.name + ": " + fly.xSpeed);
		runAction(ufo, fly, this);
	}
}
```

#### CCFlyAction
物理学相关公式主要在这块使用，update中进行位移的相关代码套用之前提到的公式即可
```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class CCFlyAction : SSAction{

	float initSpeed;	//初速度
	float gravity;		//重力系数
	float angle;        //初速度的角度
	float xSpeed, ySpeed;

	private CCFlyAction() { }

	public static CCFlyAction getSSAction(float speed, float gravity, float angle) {
		CCFlyAction action = CreateInstance<CCFlyAction>();
		action.initSpeed = speed;
		action.gravity = gravity;
		action.angle = angle;
		action.xSpeed = speed * Mathf.Cos(angle* Mathf.Deg2Rad);
		action.ySpeed = speed * Mathf.Sin(angle* Mathf.Deg2Rad);
		//Debug.Log(Mathf.Cos(angle));
		return action;
	}

	public override void Start() {
		//不需要做任何事
	}

	public override void Update() {
		transform.position += new Vector3(xSpeed * Time.deltaTime, (ySpeed - gravity * Time.deltaTime / 2) * Time.deltaTime, 0);
		ySpeed -= gravity * Time.deltaTime;

		if (transform.position.y < -10f) { //飞碟位置小于-10，结束动作
			destroy = true;
			callback.SSActionEvent(this);       //回调告知动作完成
		}
	}
}
```

#### ISceneController.cs
添加了一个枚举类型，用来记录游戏状态，在userGUI和firstController中会使用到  
四个状态分别对应游戏开始前，每个回合开始前，正在进行游戏，游戏结束
```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public enum GameState { GameReady,RoundReady,Running,Finish};

public interface ISceneController{
	void LoadResources();
}
```

#### UserGUI.cs
```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class UserGUI : MonoBehaviour{
    private IUserAction action;

	GUIStyle label_style = new GUIStyle();
	GUIStyle detail_style = new GUIStyle();

	void Start (){
        action = SSDirector.getInstance().currentSceneController as IUserAction;
		
		label_style.normal.textColor = Color.black;
		label_style.alignment = TextAnchor.MiddleCenter;
		label_style.fontSize = 24;
		detail_style.normal.textColor = Color.black;
		detail_style.fontSize = 18;
	}
	
	void OnGUI (){
		if (action.getGameState() == GameState.GameReady) {
			if (GUI.Button(new Rect(Screen.width / 2 - 50, Screen.height / 2 - 20, 100, 40), "游戏开始")) {
				action.setGameState(GameState.RoundReady);
			}
		}
		else if(action.getGameState() == GameState.Running) {
			GUI.Label(new Rect(Screen.width / 2 - 30, 20, 60, 40), "Round " + action.getRound().ToString(), label_style);
			GUI.Label(new Rect(10, 10, 200, 40), "分数: " + action.getScore().ToString(), detail_style);
            GUI.Label(new Rect(10, 50, 100, 40), "生命: " + action.getHealth().ToString(), detail_style);
		}
		else if (action.getGameState() == GameState.Finish) {
			GUI.Label(new Rect(Screen.width / 2 - 50, Screen.height / 2 - 60, 100, 40), "游戏结束", label_style);
			GUI.Label(new Rect(Screen.width / 2 - 50, Screen.height / 2 - 20, 100, 40), "最终得分：" + action.getScore().ToString(), label_style);
			if (GUI.Button(new Rect(Screen.width / 2 - 50, Screen.height / 2 + 20, 100, 40), "重新开始")) {
				action.ReStart();
				action.setGameState(GameState.RoundReady);
			}
		}
    }
}
```

#### IUserAction.cs
```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public interface IUserAction{
	void setGameState(GameState state);
	GameState getGameState();
	int getScore();
	int getRound();
	int getHealth();
	void ReStart();
}
```

#### FirstController.cs
负责飞碟的发射，游戏交互的反馈，以及切换游戏状态，计分等功能
```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class FirstController : MonoBehaviour, ISceneController, IUserAction{
    public CCActionManager am;
    public UFOFactory ufo_factory;
    public UserGUI user_gui;

	int score = 0;                                                  //分数
	int health = 5;													//血量
	int round = 0;                                                  //回合
	float gravity = 1f;												//所受重力
	float time = 0;													//发射时间间隔
	GameState gs = GameState.GameReady;								//游戏状态
    Queue<GameObject> ufo_queue = new Queue<GameObject>();          //游戏场景中的飞碟队列
	List<GameObject> no_shot_list = new List<GameObject>();			//未被击中的飞碟列表
    
    void Awake (){
        SSDirector director = SSDirector.getInstance();     
        director.currentSceneController = this;
		this.gameObject.AddComponent<UFOFactory>();
		ufo_factory = Singleton<UFOFactory>.Instance;
        am = gameObject.AddComponent<CCActionManager>() as CCActionManager;
        user_gui = gameObject.AddComponent<UserGUI>() as UserGUI;
		this.LoadResources();
    }
	
	void Update (){
		if(gs == GameState.Running) {
			if (health == 0)
				gs = GameState.Finish;
			else {
				if (Input.GetButton("Fire1")) {
					Vector3 pos = Input.mousePosition;
					hitUFO(pos);
				}

				//判断飞碟是否飞出视角
				foreach(var tmp in no_shot_list) {
					if (tmp.transform.position.x < -13|| tmp.transform.position.x > 13|| tmp.transform.position.y < 0) {
						health--;
						no_shot_list.Remove(tmp);
						break;
					}
				}

				//隔一段时间发射一个飞碟
				if (time > 1.5 - round * 0.1f) {
					launchUFO();
					time = 0;

					//当前轮结束，进入下一轮
					if (no_shot_list.Count == 0) {
						gs = GameState.RoundReady;
					}
				}
				else
					time += Time.deltaTime;
			}
		}

		if (gs == GameState.RoundReady && health > 0) {
			gs = GameState.Running;
			round++;
			time = 0;
			nextRound();
		}
	
    }

	void nextRound() {
		for (int i = 0; i < 10; i++) {
			GameObject tmp = ufo_factory.getUFO(round);
			tmp.name = "ufo" + (i + 1);
			ufo_queue.Enqueue(tmp);
		}
	}

    public void LoadResources(){
		 
    }

    void launchUFO(){
		if (ufo_queue.Count != 0) {
			GameObject ufo = ufo_queue.Dequeue();

			ufo.transform.position = ufo.GetComponent<UFOData>().pos;
			ufo.transform.localScale = ufo.GetComponent<UFOData>().scale;
			ufo.GetComponent<Renderer>().material.color = ufo.GetComponent<UFOData>().color;
			ufo.SetActive(true);

			no_shot_list.Add(ufo);
			am.UFOFly(ufo, gravity);
		}
    }

    void hitUFO(Vector3 pos){
        Ray ray = Camera.main.ScreenPointToRay(pos);
        RaycastHit[] hits;
        hits = Physics.RaycastAll(ray);

        foreach (var hit in hits){
            if (hit.collider.gameObject.GetComponent<UFOData>() != null) {
				//Debug.Log(hit.collider.gameObject.name);
				score += hit.collider.gameObject.GetComponent<UFOData>().score;
				no_shot_list.Remove(hit.collider.gameObject);
				hit.collider.gameObject.transform.position = new Vector3(0, -9f, 0);
			}
        }
    }

	public void setGameState(GameState state) {
		gs = state;
	}

	public GameState getGameState() {
		return gs;
	}

    public int getScore(){
        return score;
    }

	public int getRound() {
		return round;
	}

	public int getHealth() {
		return health;
	}

	public void ReStart(){
		score = 0;
		health = 5;
		round = 0;
		time = 0;
		ufo_queue.Clear();
    }
}
```

以下都是复用的代码，这里不做赘述  
> SSDirector.cs
```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class SSDirector : System.Object{
	private static SSDirector _instance;
	public ISceneController currentSceneController { get; set; }
	public static SSDirector getInstance() {
		if (_instance == null)
			_instance = new SSDirector();
		return _instance;
	}
}
```

> Singleton.cs
```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Singleton<T> : MonoBehaviour where T : MonoBehaviour {
	protected static T instance = null;

	public static T Instance {
		get {
			if (instance == null) {
				instance = (T)FindObjectOfType(typeof(T));
				if (instance == null) {
					Debug.LogError("An instance of " + typeof(T) + " is needed in the scene, but there is none.");
					//instance = new GameObject("Singleton of " + typeof(T).ToString(), typeof(T)).GetComponent<T>();
				}
			}
			return instance;
		}
	}
}
```

> SSAction.cs
```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class SSAction : ScriptableObject{
	public bool destroy = false;	//该动作对象是否需要销毁

	public GameObject gameobject { get; set; }
	public Transform transform { get; set; }
	public ISSActionCallBack callback { get; set; }

	protected SSAction() { }

	public virtual void Start() {
		throw new System.NotImplementedException();
	}

	public virtual void Update() {
		throw new System.NotImplementedException();
	}
}
```

> SSActionManager.cs
```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class SSActionManager : MonoBehaviour{
	Dictionary<int, SSAction> executing = new Dictionary<int, SSAction>();
	List<SSAction> waitToDo = new List<SSAction>();
	List<int> waitToDestroy = new List<int>();

	protected void Update() {
		foreach(SSAction act in waitToDo) {
			executing[act.GetInstanceID()] = act;
		}
		waitToDo.Clear();

		foreach(KeyValuePair<int, SSAction> kv in executing) {
			SSAction act = kv.Value;
			//当前动作做完就该被销毁，否则继续执行
			if (act.destroy)
				waitToDestroy.Add(act.GetInstanceID());
			else
				act.Update();
		}

		foreach(int key in waitToDestroy) {
			SSAction act = executing[key];
			executing.Remove(key);
			Destroy(act);
		}

		waitToDestroy.Clear();
	}

	public void runAction(GameObject gameobject,SSAction action,ISSActionCallBack manager) {
		action.gameobject = gameobject;
		action.transform = gameobject.transform;
		action.callback = manager;
		waitToDo.Add(action);
		action.Start();
	}
}
```

> ISSActionCallBack.cs
```c#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public interface ISSActionCallBack{
	//event为0代表动作正在执行，1为完成
	void SSActionEvent(SSAction src, int events = 1, int int_param = 0, string str_param = null, Object obj_param = null);
}
```
